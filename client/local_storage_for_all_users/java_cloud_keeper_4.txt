package com.geekcloud.auth;

import com.geekcloud.auth.exceptions.AuthServiceException;
import com.geekcloud.auth.exceptions.DatabaseConnectionException;
import com.geekcloud.auth.exceptions.UserAlreadyExistsException;

import java.util.List;

public interface AuthService {
    void start() throws AuthServiceException;
    void stop();
    String getNickByLoginPass(String username, String password);
    boolean isLoginAccepted(String username, String password);
    boolean isUserNameVacant(String username);
    void registerNewUser (String username, String password, String nick) throws UserAlreadyExistsException, DatabaseConnectionException;
    void deleteUser (String username, String password) throws DatabaseConnectionException;
    List<String> listRegisteredUsers();
}

package com.geekcloud.auth;

import com.geekcloud.auth.exceptions.UserAlreadyExistsException;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class BaseAuthService implements AuthService{

    private Map <String, User> users;

    private class User {
        private String login;
        private String password;
        private String nick;

        User(String login, String password, String nick) {
            this.login = login;
            this.password = password;
            this.nick = nick;
        }
        String getPassword() { return password; }
        String getNick() { return nick; }
    }

    public BaseAuthService(){
        this.users = new HashMap<>();
    }

    public void start(){
        testPrefill(); // TODO убрать по завершении разработки
    }

    public void stop(){}

    private void testPrefill () {
        users.put("login1", new User ("login1", "pass1", "Rick"));
        users.put("login2", new User ("login2", "pass2", "Morty"));
        users.put("login3", new User ("login3", "pass3", "Bet"));
    }

    public String getNickByLoginPass(String login, String pass){
        return users.containsKey(login) ? users.get(login).getNick() : null;
    }

    public boolean isLoginAccepted(String username, String password) {
        if (!users.containsKey(username)) return false;
        return users.get(username).getPassword().equals(password);
    }

    public boolean isUserNameVacant(String username) {
        return !users.containsKey(username);
    }

    public synchronized void registerNewUser(String username, String password, String nick) throws UserAlreadyExistsException {
        if (users.containsKey(username)) throw new UserAlreadyExistsException();
        users.put(username, new User(username, password, nick));
    }

    public void deleteUser(String username, String password) {
        if(isLoginAccepted(username, password)) {
            users.remove(username);
        }
    }

    public List<String> listRegisteredUsers() {
        return new ArrayList<>(users.keySet());
    }
}

package com.geekcloud.auth;

import com.geekcloud.auth.exceptions.AuthServiceException;
import com.geekcloud.auth.exceptions.DatabaseConnectionException;
import com.geekcloud.auth.exceptions.UserAlreadyExistsException;

import java.nio.file.Files;
import java.nio.file.Paths;
import java.security.MessageDigest;
import java.sql.*;
import java.util.LinkedList;
import java.util.List;

// Имплементация интерфейса AuthService с подключением к базе данных.
public class SqliteAuthService implements AuthService {

    private final String DATABASE_URL;
    private Connection connection;
    private List<PreparedStatement> preparedStatements;
    private PreparedStatement authQuery;
    private PreparedStatement findUserQuery;
    private PreparedStatement registerNewUserQuery;
    private PreparedStatement deleteUserQuery;
    private PreparedStatement listAllUsersQuery;

    public SqliteAuthService(String databaseURL) {
        this.DATABASE_URL = databaseURL;
    }

    // запуск службы - проверка наличия базы, её создание в случае необходимости,
    // подключение, заготовка PreparedStatements, заполнение тестовыми записями
    public synchronized void start() throws DatabaseConnectionException {
        try {
            this.connection = DriverManager.getConnection("jdbc:sqlite:"+DATABASE_URL);
            checkCreateUsersTable();
            prepareStatements();
            testPrefill(); // TODO убрать по завершении разработки
        } catch (SQLException | AuthServiceException e) {
            throw new DatabaseConnectionException();
        }
    }

    // Тестовые данные для базы - только на стадии разработки
    private synchronized void testPrefill() throws AuthServiceException {
        String [] [] testUsers = {
                {"login1",  "pass1", "Rick"},
                {"login2",  "pass2", "Morty"},
                {"login3",  "pass3", "Bet"}};
        try {
            MessageDigest digest = MessageDigest.getInstance("MD5");
            for (int i = 0; i < 3; i++) {
                digest.update(testUsers[i][1].getBytes());
                if (isUserNameVacant(testUsers[i][0]))
                    registerNewUser(testUsers[i][0], new String(digest.digest()), testUsers[i][2]);
                if(Files.notExists(Paths.get(DATABASE_URL).getParent().resolve(testUsers[i][0])))
                    Files.createDirectory(Paths.get(DATABASE_URL).getParent().resolve(testUsers[i][0]));
            }
        } catch (Exception e) { }
    }

    private void checkCreateUsersTable() throws SQLException {
        connection.createStatement().executeUpdate("CREATE TABLE IF NOT EXISTS users (" +
                "    user CHAR (20) NOT NULL UNIQUE," +
                "    password CHAR (12) NOT NULL, " +
                "    nick CHAR (20) NOT NULL);" +
                "    CREATE UNIQUE INDEX IF NOT EXISTS i_users ON users (user);");
    }

    private void prepareStatements () throws SQLException {

        preparedStatements = new LinkedList<>();

        authQuery = connection.prepareStatement("SELECT * FROM users WHERE user = ? AND password = ? LIMIT 1");
        preparedStatements.add(authQuery);

        findUserQuery = connection.prepareStatement("SELECT * FROM users WHERE user = ? LIMIT 1");
        preparedStatements.add(findUserQuery);

        registerNewUserQuery = connection.prepareStatement("INSERT INTO users (user, password, nick) VALUES (?, ?, ?)");
        preparedStatements.add(registerNewUserQuery);

        deleteUserQuery = connection.prepareStatement("DELETE FROM users WHERE user = ?");
        preparedStatements.add(deleteUserQuery);

        listAllUsersQuery = connection.prepareStatement("SELECT user FROM users");
        preparedStatements.add(listAllUsersQuery);
    }

    // остановка службы - закрытие стейтментов и подключения
    public void stop() {
        try {
            for (PreparedStatement ps: preparedStatements) ps.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
        try {
            connection.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }

    }

    // Возвращаем ник по логину и паролю,
    // или null, если пара логин/пароль не найдена
    public synchronized String getNickByLoginPass(String login, String pass) {
        try {
            authQuery.setString(1, login);
            authQuery.setString(2, pass);
            ResultSet resultSet = authQuery.executeQuery();
            if (resultSet.next()) {
                return resultSet.getString("nick");
            }
            return null;
        } catch (SQLException e) {
            e.printStackTrace();
            return null;
        }
    }

    // все методы ниже синхронизированы, т.к. работают через один и тот же набор PreparedStatements

    // проверяем, есть ли в базе записи с указанным логином и (хеш-)паролем.
    // если запрос возвращается пустой или происходит ошибка - отвечаем false
    public synchronized boolean isLoginAccepted(String username, String password) {
        try {
            authQuery.setString(1, username);
            authQuery.setString(2, password);
            return authQuery.executeQuery().next();
        } catch (SQLException e) {
            e.printStackTrace();
            return false;
        }
    }

    // проверяем, не занят ли в базе указанный логин
    // метод вынесен отдельно от регистрации, чтобы иметь возможность проверить на стадии заполнения формы
    public synchronized boolean isUserNameVacant(String username) {
        try {
            findUserQuery.setString(1, username);
            return !findUserQuery.executeQuery().next();
        } catch (SQLException e) {
            e.printStackTrace();
            return false;
        }
    }

    // регистрация нового пользователя
    public synchronized void registerNewUser(String username, String password, String nick) throws UserAlreadyExistsException, DatabaseConnectionException {
        if (isUserNameVacant(username)) {
            try {
                registerNewUserQuery.setString(1, username);
                registerNewUserQuery.setString(2, password);
                registerNewUserQuery.setString(3, nick);
                registerNewUserQuery.executeUpdate();
            } catch (SQLException e) {
                throw new DatabaseConnectionException();
            }
        } else throw new UserAlreadyExistsException();
    }

    // удаление пользователя (с паролем для проверки полномочий на удаление)
    public synchronized void deleteUser (String username, String password) throws DatabaseConnectionException {
        if (isLoginAccepted(username, password)) {
            try {
                deleteUserQuery.setString(1, username);
                if (deleteUserQuery.executeUpdate() < 1) throw new DatabaseConnectionException();
            } catch (SQLException e) {
                throw new DatabaseConnectionException();
            }
        }
    }

    // список всех зарегистрированных в базе пользователей
    public List<String> listRegisteredUsers() {
        List <String> list = new LinkedList<>();
        try {
            ResultSet resultSet = listAllUsersQuery.executeQuery();
            while (resultSet.next()) list.add(resultSet.getString(1));
            return list;
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return list;
    }
}

package MyClient;


import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.net.Socket;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;

import io.netty.handler.codec.serialization.ObjectEncoderOutputStream;
import com.geekcloud.common.settings.ServerConst;
import com.geekcloud.common.messaging.*;

public class ClientConnection implements ServerConst, Server_API {
    Socket socket;
    DataOutputStream out;
    DataInputStream in;
    ObjectEncoderOutputStream oeos;
    private boolean isAuthrozied = false;

    public boolean isAuthrozied() {
        return isAuthrozied;
    }

    public void setAuthrozied(boolean authrozied) {
        isAuthrozied = authrozied;
    }

    public ClientConnection() {
    }

    public void init(Controller view) { //lazy init
        try {
            this.socket = new Socket(SERVER_URL, PORT);
            this.out = new DataOutputStream(socket.getOutputStream());
            this.in = new DataInputStream(socket.getInputStream());
            this.oeos = new ObjectEncoderOutputStream(socket.getOutputStream());
            new Thread(() -> {
                try {
                    while (true) {
                        String message = in.readUTF();
                        System.out.println("here");
                        if (message.startsWith(AUTH_SUCCESSFUl)) {
                            setAuthrozied(true);
                            view.switchWindows();
                            break;
                        }
                        view.showMessage(message);
                    }
                    while (true) {
                        String message = in.readUTF();
                        String[] elements = message.split(" ");
                        if (message.startsWith(SYSTEM_SYMBOL)) {
                            if (elements[0].equals(CLOSE_CONNECTION)) {
                                setAuthrozied(false);
                                view.showMessage(message.substring(CLOSE_CONNECTION.length() + 1));
                                view.switchWindows();
                            } else if (message.startsWith(USERS_LIST)) {
                                String[] users = message.split(" ");
                                Arrays.sort(users);
                                System.out.println(Arrays.toString(users));
                                view.showUsersList(users);
                            }

                        } else {
                            view.showMessage(message);
                        }
                    }
                } catch (IOException e) {
                } finally {
                    disconnect();
                }
            }).start();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public void sendMessage(String message) {
        try {
            out.writeUTF(message);
            out.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public void auth(String login, String password) {
        try {
            MessageDigest digest = java.security.MessageDigest.getInstance("MD5");
            digest.update(password.getBytes());
            AuthMessage authMessage = new AuthMessage(login, new String (digest.digest()));
            oeos.writeObject(authMessage);
            oeos.flush();
        } catch (IOException e) {
            e.printStackTrace();
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
    }

    public void disconnect() {
        try {
            out.writeUTF(CLOSE_CONNECTION);
            oeos.close();
            socket.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

}

package MyClient;

import javafx.fxml.FXML;
import javafx.scene.control.PasswordField;
import javafx.scene.control.TextField;
import javafx.scene.layout.Pane;

public class Controller {

    private ClientConnection clientConnection;

    @FXML private Pane authPanel;
    @FXML private TextField loginField;
    @FXML private PasswordField passField;
    @FXML private Pane workArea;

    @FXML private void initialize() {
        this.clientConnection = new ClientConnection();
        clientConnection.init(this);
    }

    @FXML
    public void auth() {
        clientConnection.auth(loginField.getText(), passField.getText());
        loginField.clear();
        passField.clear();
    }

    public void switchWindows() {
        authPanel.setVisible(!clientConnection.isAuthrozied());
        workArea.setVisible(clientConnection.isAuthrozied());
    }

    public void showMessage(String message) {
        // метод будет заменен при переработке функционала с чата на облачное хранилище
    }

    public void showUsersList(String[] users) {
        // метод будет заменен при переработке функционала с чата на облачное хранилище
    }
}

package MyClient;

import javafx.application.Application;
import javafx.fxml.FXMLLoader;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.stage.Stage;

public class Main extends Application {
    @Override
    public void start(Stage primaryStage) throws Exception {
        Parent root = FXMLLoader.load(getClass().getClassLoader().getResource("sample.fxml")); //вот тут пришлось добавить getClassLoader(), иначе не получилось грузить fxml
        primaryStage.setTitle("GeekCloud Client");
        primaryStage.setScene(new Scene(root, 600, 600));
        primaryStage.show();
    }

    public static void main(String[] args) {
        launch(args);

    }
}

package com.geekcloud.common.messaging;

import java.io.Serializable;

//Этим классом передавать сообщения для авторизации
public class AuthMessage implements Serializable {

    private static final long serialVersionUID = 5193392663743561680L;

    private String login;
    private String password;

    public AuthMessage(String login, String password) {
        this.login = login;
        this.password = password;
    }

    public String getLogin() {
        return login;
    }

    public void setLogin(String login) {
        this.login = login;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}

package com.geekcloud.common.messaging;

public enum Command {
    // нужно прикинуть, какие ещё действия могут понадобиться пользователю
    CREATE,
    DELETE,
    DOWNLOAD,
    LIST_FILES,
    RENAME
}

package com.geekcloud.common.messaging;

// в объекты этого класса будут заворачиваться команды от пользователя
// с указанием необходимых для исполнения команды параметров (имя файла, папки и т.п.)
public class CommandMessage {

    private static final long serialVersionUID = 5193392663743561680L;

    private Command command;
    private String fileName;
    private String newFileName;
    private String directoryName;
    private String newDirectoryName;

    public Command getCommand() { return command; }
    public String getFileName() { return fileName; }
    public String getNewFileName() { return newFileName; }
    public String getDirectoryName() { return directoryName; }
    public String getNewDirectoryName() { return newDirectoryName; }

    public void setCommand(Command command) { this.command = command; }
    public void setFileName(String fileName) { this.fileName = fileName; }
    public void setNewFileName(String newFileName) { this.newFileName = newFileName; }
    public void setDirectoryName(String directoryName) { this.directoryName = directoryName; }
    public void setNewDirectoryName(String newDirectoryName) { this.newDirectoryName = newDirectoryName; }

}

package com.geekcloud.common.messaging;

import java.io.Serializable;

public class MyMessage implements Serializable {
    //Этот класс для пересылки файлов
    private static final long serialVersionUID = 5193392663743561680L;

    private String text;

    public String getText() {
        return text;
    }

    public MyMessage(String text) {
        this.text = text;
    }
}

package com.geekcloud.common.messaging;

public enum Result {
    OK, FAILED
}

package com.geekcloud.common.messaging;

public class ResultMessage {

    private Result result;

    public ResultMessage (Result result) {
        this.result = result;
    }

    public Result getResult() {
        return result;
    }
}

package com.geekcloud.common.messaging;

public interface Server_API {
    String SYSTEM_SYMBOL = "/";
    String CLOSE_CONNECTION = "/end";
    String AUTH = "/auth";
    String AUTH_SUCCESSFUl = "/authok";
    String PRIVATE_MESSAGE = "/w";
    String USERS_LIST = "/userslist";
}

package com.geekcloud.common.messaging;

public class ServiceMessage {
    //Класс для отправки служебных сообщений клиенту
    //Надо придумать куда их в клиентском интерфейсе выводить
    private String text;

    public ServiceMessage(String text) {
        this.text = text;
    }

    public String getText() {
        return text;
    }
}

package com.geekcloud.common.settings;

public interface ServerConst {
    int PORT = 8189;
    String SERVER_URL = "localhost";
}


package scrNettyServer;

import com.geekcloud.auth.AuthService;
import com.geekcloud.auth.SqliteAuthService;
import com.geekcloud.auth.exceptions.AuthServiceException;
import io.netty.bootstrap.ServerBootstrap;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelInitializer;
import io.netty.channel.ChannelOption;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.socket.nio.NioServerSocketChannel;
import io.netty.handler.codec.serialization.ClassResolvers;
import io.netty.handler.codec.serialization.ObjectDecoder;
import com.geekcloud.common.settings.ServerConst;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.LinkOption;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.logging.Logger;

public class CloudServer {

    private final Path ROOT = Paths.get("_cloud_repository");
    private static final int MAX_OBJ_SIZE = 1024 * 1024 * 100; // 10 mb
    private AuthService authService;

    private void run() {

        // Для хранения файлов на сервере выделяем директорию.
        // В ней будет лежать файл базы данных пользователей для сервиса авторизации
        // и файлы пользователей, разложенные по папкам с именами логинов.
        // Шаг 1: проверяем наличие папки на сети, при отсутствии - создаем.
        if(Files.exists(ROOT, LinkOption.NOFOLLOW_LINKS)) {
            Logger.getGlobal().info("ROOT DIRECTORY " + ROOT);
        } else {
            try {
                Files.createDirectory(ROOT);
                Logger.getGlobal().warning("ATTENTION! --- NEW ROOT DIRECTORY CREATED " + ROOT);
            } catch (IOException e) {
                Logger.getGlobal().severe("FATAL ERROR! FAILED TO CREATE ROOT DIRECTORY. \nSERVER CLOSED");
                return;
            }
        }

        // Шаг 2: Запускаем службу авторизации
        try {
            authService = new SqliteAuthService(ROOT.resolve("users").toAbsolutePath().toString());
            authService.start();
            Logger.getGlobal().info("AUTHORISATION SERVICE STARTED");
        } catch (AuthServiceException e) {
            Logger.getGlobal().severe("FATAL ERROR! FAILED TO START AUTHORISATION SERVICE. \nSERVER CLOSED");
            return;
        }

        // Шаг 3: Запускаем нетти-сервер
        EventLoopGroup mainGroup = new NioEventLoopGroup();
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        try {
            ServerBootstrap b = new ServerBootstrap();
            b.group(mainGroup, workerGroup)
                    .channel(NioServerSocketChannel.class)
                    // .handler(new LoggingHandler(LogLevel.INFO))
                    .childHandler(new ChannelInitializer<SocketChannel>() {
                        protected void initChannel(SocketChannel socketChannel) {
                            socketChannel.pipeline().addLast(
                                    new ObjectDecoder(MAX_OBJ_SIZE, ClassResolvers.cacheDisabled(null)),
                                    new CloudServerHandler(ROOT.toAbsolutePath(), authService)
                            );
                        }
                    })
                    .option(ChannelOption.SO_BACKLOG, 128)
                    .option(ChannelOption.TCP_NODELAY, true)
                    .childOption(ChannelOption.SO_KEEPALIVE, true);
            ChannelFuture future = b.bind(ServerConst.PORT).sync();
            future.channel().closeFuture().sync();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            mainGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
            authService.stop();
        }
    }

    public static void main(String[] args) {
        new CloudServer().run();
    }
}


package scrNettyServer;


import com.geekcloud.auth.AuthService;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHandlerAdapter;
import io.netty.util.ReferenceCountUtil;
import com.geekcloud.common.messaging.*;

import java.net.InetAddress;
import java.nio.file.Files;
import java.nio.file.LinkOption;
import java.nio.file.Path;
import java.util.logging.Logger;

public class CloudServerHandler extends ChannelInboundHandlerAdapter {

    private String login;
    private final Path SERVER_DIRECTORY; // нужна, чтобы знать, куда пользователя уже не пускать
    private Path currentDirectory; // нужна, чтобы знать, в какой серверной папке работает пользователь
    private final AuthService AUTH_SERVICE;
    private boolean isAuth;

    public CloudServerHandler (Path serverDirectory, AuthService AUTH_SERVICE) {
        this.SERVER_DIRECTORY = serverDirectory;
        this.AUTH_SERVICE = AUTH_SERVICE;
    }

    @Override
    public void channelActive(ChannelHandlerContext ctx) throws Exception {
        Logger.getGlobal().info("CLIENT CONNECTED: " + InetAddress.getLocalHost().getHostName());
        // Send greeting for a new connection.
        // ctx.write("Welcome to " + InetAddress.getLocalHost().getHostName() + "!\r\n");
        // ctx.write("It is " + new Date() + " now.\r\n");
        // ctx.flush();
    }

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        try {

            if (msg == null) return;

            if (!isAuth) {
                if (msg instanceof AuthMessage) {
                    String login = ((AuthMessage) msg).getLogin();
                    String password = ((AuthMessage) msg).getPassword();

                    if (AUTH_SERVICE.isLoginAccepted(login, password)) {
                        // Проверяем, на месте ли папка с файлами пользователя
                        if(Files.isDirectory(SERVER_DIRECTORY.resolve(login), LinkOption.NOFOLLOW_LINKS)) {
                            currentDirectory = SERVER_DIRECTORY.resolve(login);
                        } else {
                            // если папки нет, пользователя пускать нельзя
                            Logger.getGlobal().severe("NO DIRECTORY FOUND FOR VALID USER " + login);
                            ctx.write(new ResultMessage(Result.FAILED));
                            ctx.flush();
                            throw new Exception("User directory not found");
                        }

                        this.login = login;
                        isAuth = true;

                        ctx.write(new ResultMessage(Result.OK));
                        // TODO вписать сюда отсылку списка файлов пользователю
                        ctx.flush();
                    } else {
                        ctx.write(new ResultMessage(Result.FAILED));
                        ctx.flush();
                    }
                }
            } else {
                if (msg instanceof CommandMessage) {
                    switch (((CommandMessage)msg).getCommand() ) {
                        case DELETE:
                        case RENAME:
                            // TODO прописать обработку команд пользователя
                    }
                } else {
                    Logger.getGlobal().warning("Server received wrong object from " + login);
                }
            }
        } finally {
            ReferenceCountUtil.release(msg);
        }
    }

    @Override
    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
        ctx.flush();
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        cause.printStackTrace();
        isAuth = false;
        ctx.flush();
        ctx.close();
    }
}
